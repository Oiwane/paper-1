\chapter{実装}\label{cha:Implementation}
テスト支援ツールの10個の機能である、「キャラクター情報入力機能」、「オブジェクト増減機能」、「オブジェクト情報入力機能」、「オブジェクト位置確認機能」、「ゲームスタートボタン機能」、「リプレイボタン機能」、
「Warning判定出力機能」、「入力キーとタイミングの記録機能」、「リプレイ機能」、「エラーメッセージ出力機能」の実装について説明する。
また、「Warning判定出力機能」の実装のために、
「ゲーム実行時のゲーム画面リアルタイム取得」、「キャラクターとオブジェクトの重なり判定」の実装について説明する。


\section{シミュレーション結果解析機能}\label{kyap_re}
「キャラクター情報入力機能」の実装方法について説明する。キャラクター情報入力ウィンドウのキャラクター情報入力部では、
キャラクター画像、キャラクター名、キャラクター情報保存を配置している。キャラクター画像と、キャラクター情報保存の処理を以下に示す。

% \subsubsection{キャラクター画像}
% \begin{enumerate}
%   \item キャラクター画像を押下すると、ダイアログボックスを表示する。
%   \item 画像を選択すると、選択した画像の大きさを、キャラクター情報入力部のキャラクター画像の大きさに合わせて画像を表示する。
%   \item キャラクター画像のファイルパスを取得する。
%   \item 取得したファイルパスは、階層を表す記号が"Y\llap{=}"になっている。キャラクター画像を読み込む際は、C++では、文字列において"Y\llap{=}"はエスケープ文字だと認識するため、
%   		エスケープ文字をエスケープする必要がある。したがって、3.で取得したファイルパスの文字列を取得し、文字列の中に"Y\llap{=}"を見つけた場合は、その横に"Y\llap{=}"を追加する。
% \end{enumerate}

% \subsubsection{キャラクター情報保存}
% \begin{enumerate}
%   \item キャラクター名とキャラクター画像を、ユーザーが入力しているかどうかを調べる。
%   \item 入力漏れがあった場合、エラーメッセージをキャラクター情報エラーメッセージ出力表示部に表示する。
%   \item 入力漏れがなかった場合、キャラクター情報入力ウィンドウを閉じる。
%   \item キャラクター情報設定部のキャラクター名に、キャラクター名入力テキストボックスでユーザーが入力した名前を表示する。
%   \item 文字列型の配列を用意して、その1行目にキャラクター名と、キャラクターのファイルパスを格納する。
% \end{enumerate}

\section{特性表生成機能}\label{gazou_input}
「オブジェクト増減機能」の実装方法について説明する。オブジェクト追加部のオブジェクト増加ボタンを押下すると、オブジェクト名とオブジェクト情報設定ボタンをオブジェクト追加部に表示する。
表示の処理を、以下に示す。また、オブジェクト名とオブジェクト情報設定ボタンを表示した状態を、図4.1に示す。

\begin{enumerate}
  \item オブジェクト増加ボタンを押下すると、オブジェクト名とオブジェクト情報設定ボタンを生成する。この操作は4回まで行える。
  \item オブジェクト名とオブジェクト情報設定ボタンの場所、サイズ、名前を設定する。
  \item オブジェクト名とオブジェクト情報設定ボタンを1つ目以外を全て非表示にする。
  \item 1.〜3.はオブジェクト増加ボタンを最初に押下した時にのみ処理を行う。2回目以降の場合は5.、6.の処理を行う。
  \item オブジェクト増加ボタンを押下すると、生成したオブジェクト名とオブジェクト情報設定ボタンを表示する。
  \item オブジェクト減少ボタンを押下すると、表示しているオブジェクト名とオブジェクト情報設定ボタンを非表示にする。
\end{enumerate}

% \begin{figure}
%   \centering
%   \includegraphics[width=9cm]{./Image/4.1.eps}
%   \caption{オブジェクト追加部のオブジェクト増加ボタンを押下した場合のツールの画面}
% \end{figure}


% \section{オブジェクト情報入力機能}\label{pre_kinou}
「オブジェクト情報入力機能」の実装方法について説明する。オブジェクト増減機能で表示した
オブジェクト情報設定ボタンを押下すると、オブジェクト情報入力ウィンドウが表示できる。
オブジェクト情報入力部では、オブジェクト座標入力テキストボックス、オブジェクト名入力テキストボックス、オブジェクト情報保存ボタンを
配置している。オブジェクト情報保存ボタンの処理を、以下に示す。

% \begin{enumerate}
%   \item オブジェクト情報保存ボタンを押下すると、オブジェクト座標入力テキストボックスと、オブジェクト名入力テキストボックスにユーザーが入力しているかどうかを確認する。
%   \item オブジェクトの左上の$x$座標の値$x_1$と右下の$x$座標の値$x_2$について$x_1$$\ge$$x_2$の関係が成り立つ場合、オブジェクト情報入力ウィンドウのエラーメッセージ出力表示部にエラーメッセージを表示する。
%   \item オブジェクトの左上の$y$座標の値$y_1$と右下の$y$座標の値$y_2$について$y_1$$\ge$$y_2$の関係が成り立つ場合、オブジェクト情報入力ウィンドウのエラーメッセージ出力表示部にエラーメッセージを表示する。
%   \item エラーが出なかった場合、オブジェクトの座標入力テキストボックスと、オブジェクト名入力テキストボックスの入力情報を変数に格納する。
%   \item オブジェクト情報入力ウィンドウを閉じる。
%   \item 文字列型の二次元配列を用意して、4.の変数の値を二次元配列に格納する。もし、既に二次元配列を用意していれば、その配列に4.の変数の値を格納する。また、この二次元配列は、4.5節のゲームスタートボタン機能で使用する。
% \end{enumerate}

% \section{オブジェクト位置確認機能}\label{objiti}
% 「オブジェクト位置確認機能」の実装方法について説明する。
% ゲームオブジェクト位置確認機能は、オブジェクト追加部のオブジェクト位置確認ボタンを押下するとオブジェクト位置確認ウィンドウが新しく生成でき、表示するキャラクター情報入力ウィンドウで利用できる。
% オブジェクト位置確認ウィンドウはゲームの背景と、背景変更ボタンで構成している。オブジェクト位置確認ウィンドウを開いた際、背景変更ボタンの処理を、以下に示す。

% \begin{enumerate}
%   \item 以前に背景を選択したかどうかを確認する。
%   \item 既に選択していた場合、ゲームの背景画像にその画像を表示する。
%   \item ユーザーがオブジェクトを追加していたら、選択した画像上にそのオブジェクトを四角形で描く。
%   \item 背景変更ボタンを押下すると、ダイアログを表示する。
%   \item 選択した画像上で、オブジェクト追加部で追加したオブジェクトの位置を、選択した画像上に四角形を描く。
%   \item 画像を選択すると、選択した画像の大きさを、オブジェクト位置確認ウィンドウのゲームの背景画像の大きさに合わせて画像を表示する。
% \end{enumerate}

% \section{ゲームスタートボタン機能}\label{gamestart}
% 「ゲームスタートボタン機能」の実装方法について説明する。
% 実行部のゲームスタートボタンを押下することによって、DLL(2.8節参照)を読み込み、利用できる。

% \begin{enumerate}
%   \item 実行部で設定できる実行するゲームファイル、報告者名と、キャラクター情報設定部で設定するキャラクター画像のファイルパスが、NULLでないかを確認する。
%   \item NULLだった場合、それぞれに対応したエラーメッセージを、エラーメッセージ出力表示部に表示して、処理を終了する。
%   \item キャラクター情報設定部で設定したキャラクター名、キャラクター画像のファイルパス、報告者名をcsvファイルにカンマ区切りで1行目に書き込む。
%   \item csvファイルに、オブジェクト情報入力機能で用意した二次元配列(4.3節の6.参照)に格納している、オブジェクトの左上と右下のオブジェクトの座標、オブジェクト名を次の行に追加で書き込んでいく。
%   \item csvファイルのファイルパスを成形(4.1節の4.参照)して、ファイルパスを変数に保存する。
%   \item C++のDLLを読み込む。DLLのメソッドに、実行したいゲームのファイルパスと、5.の変数に格納しているcsvファイルのファイルパスを引数として渡す。
% \end{enumerate}

% \section{リプレイボタン機能}\label{replay}
% 「リプレイボタン機能」の実装方法について説明する。
% 実行部のリプレイボタンを押下することによって、DLLを読み込み、利用できる。

% \begin{enumerate}
%   \item リプレイファイルのファイルパスと、実行するゲームの実行ファイルのファイルパス
%   が、データ入力部で設定しているかどうかを確認する。
%   \item もし、設定していない場合は、それぞれに対応したエラーメッセージを、テスト支援ツールのエラーメッセージ出力表示部に表示する。
%   \item 設定している場合は、C++のDLLを読み込む。DLLのメソッドには、実行したいゲームのファイルパスと、リプレイファイルのファイルパスを引数として渡す。
% \end{enumerate}


% \section{ゲーム実行時のゲーム画面リアルタイム取得}\label{rialtaime_display}
% ゲーム画面のキャラクターの追跡と、キャラクターとオブジェクトの重なり判定を見るために、
% ゲーム画面の画像データが必要になる。時間経過やユーザーの操作によって、
% ゲーム画面は変化していくため、リアルタイムに画像データを取得する必要がある。
% 今回は、この処理を実現するために、WindowsAPIを用いる(表2.1参照)。リアルタイムにゲーム画面を取得するための処理を、以下に示す。

% \begin{enumerate}
%   \item 実行部で設定したゲームのファイルパスからゲームウィンドウのタイトルを取得する。
%   \item GetForegroundWindow関数を使い、現在ユーザーが作業しているフォアグラウンドウィンドウのハンドルを取得する。
%   \item GetWindowText関数を使い、フォアグラウンドウィンドウのタイトルを取得する。
%   \item テスト支援ツールのデータ入力部で設定したゲームが起動しているかを確かめるために、フォアグラウンドウィンドウのタイトルと、設定したゲームウィンドウのタイトルが同じかを確かめる。同じであれば5.に進む。
%   \item パーティクルフィルターの誤認識を防ぐために、Unityのロゴの影響を受けない時間(1秒間)待つ。
%   \item 2.で取得したハンドルを使い、ゲームウィンドウを画像データに変換する処理を行う。以下、変換処理について説明する。
  
% 	\begin{enumerate}
%   		\item GetClientRect関数を使い、引数として、取得したウィンドウのクライアント領域の座標を渡す。領域の左上の座標は、常に(0,0)になる。
%   		\item (a)で取得した、ウィンドウのクライアント領域の座標を基に、画像の縦横の大きさを、それぞれ変数に代入する。
%   		\item GetDC関数を使い、ゲーム画面のウィンドウのハンドルを取得する。
%   		\item CreateDIBSection関数を使い、ゲーム画面と同じ大きさの空の画像を作成する。
%   		\item CreateCompatibleDC関数を使い、空の画像のメモリデバイスコンテキストのハンドルを取得する。
%   		\item ゲーム画面のウィンドウのハンドルから、ゲーム画面ウィンドウの情報を取得する。
%   		\item 空の画像のハンドルは、(f)で取得した情報を基に、空の画像に同じゲーム画面を描画する。
%   		\item (g)で作成した画像をOpenCvで利用できる型に変更する。
% 	\end{enumerate}
% \end{enumerate}

% \section{キャラクターとオブジェクトの重なり判定}\label{cha_tui}
% 「キャラクターとオブジェクトの重なり判定」の実装方法について説明する。
% キャラクターとオブジェクトの重なり判定のために、キャラクターを追跡する。
% キャラクターの追跡には、パーティクルフィルターを用いる(2.7節参照)。
% 重なり判定は、オブジェクトの範囲内に含まれるパーティクル数の割合で判定する。
% キャラクターとオブジェクトの重なり判定を行うための処理を、以下に示す。
% なお、ゲーム実行時に1.を実行し、ゲーム実行中は2.から7.の処理を繰り返し実行する。

% \begin{enumerate}
%   \item キャラクター追跡開始時、ゲーム画面にパーティクル$P_{i}\ (i=1,2,3,\ldots,N)$をランダムで配置する。ここで、$N$はパーティクル数を表す(今回は$N=300$とした)。
%   \item 配置したパーティクル数$N$だけ3.の処理を繰り返す。
%   \item パーティクルの座標を中心として、指定したキャラクター画像のサイズと等しい範囲をゲーム画面から切り取る。ただし、パーティクルの中心座標がゲーム画面の領域外ならば、パーティクルの尤度を0とする。
%   	\begin{enumerate}
%   		\item 抽出した領域における画像のヒストグラムと、キャラクター画像のヒストグラムの類似度を計算する。
% 		\item (a)で計算したヒストグラムの類似度をパーティクルの尤度とする。
% 	\end{enumerate}
% 	\item 各パーティクルの尤度$P_{i}^{(L)}\ (i=1,2,3,\ldots,N)$が$\displaystyle\sum_i P_i^{(L)} = 1$を満たすように、全パーティクル数の尤度の合計で割って、正規化する。 
% 	\item 各パーティクルの座標が、オブジェクトの範囲内である割合によって、キャラクターがオブジェクトに重なっていると判定する(今回は、重なり判定とみなす割合を40\%とした)。
% 	オブジェクトに重なっていると判定した場合、二次元配列にオブジェクト名と時刻を記録する。
%   	\item パーティクル$P_i$を尤度$P_i^{(L)}$に従う確率でリサンプリングし、新たなパーティクルの集合$\{P_i\mid i=1,2,\ldots,N\}$を生成する。リサンプリングの方法を、以下に示す。
% 	  また、重なり判定で使用するリサンプリングの図を、図4.2に示す。
%     	\begin{enumerate}
%   			\item パーティクルの尤度$P_i^{(L)}$について$F(x)=\displaystyle\sum_{i=1}^x P_i^{(L)}(0 \leq x \leq N)$となる関数$F(x)$を定義する。ここで$F(0) = 0$、$F(N) = 1$とする。
% 			\item 区間[0,1]の一様分布に従う乱数$u$を生成し、パーティクルのインデックス$v = F^{-1}(u)$を得る。ただし、$u$が$F(k) < u < F(k+1)\ (k=0,1,\ldots,N-1)$のとき、$v=k+1$とする。
% 			\item (b)で取得した$v$から、$P_v$を新たなパーティクルとする。
% 		\end{enumerate}
% 	\item 新たに生成したパーティクルを用いて次状態のキャラクターの位置を予測する。
% 	そのために、6.で生成した各パーティクルの座標にノイズを加える(実験を行った結果、効果的にキャラクターを追跡できる区間[-80,80]の一様分布に従う乱数を今回は採用した)。
% \end{enumerate}

% パーティクルの数を300個にした理由は、パーティクル数を多くすると、キャラクターの追跡処理にCPU時間がとられ、ゲームの動作が重くなってしまうためである。

% 重なり判定とみなす割合を40\%に設定した理由は、値を大きくすると多少の重なりではオブジェクトとの重なりを検出せず、また、値を小さくすると重なっていない場合に
% 重なっていると誤認識するためである。

% パーティクルの座標に加えるノイズは、値を小さくし過ぎると、キャラクターが大きく移動した際に、パーティクルがキャラクターを追跡できなくなってしまう。
% また、値を大きくし過ぎた場合もキャラクターにパーティクルが集まらずに、追跡できなくなってしまう。そのため、今回は区間[-80,80]の一様分布に従う乱数にした。

% % \begin{figure}[t]
% %   \centering
% %   \includegraphics[width=9cm]{./Image/4.7.eps}
% %   \caption{重なり判定で使用するリサンプリング}
% % \end{figure}

% \section{Warning判定出力機能}\label{pre_kinou}
% 「キャラクターとオブジェクトの重なり判定」の結果を、報告書としてファイルへ出力する。
% ファイルへの出力は、実行しているゲームを終了した際に行う。以下に、処理の実装を示す。

% \begin{enumerate}
%   \item 同じ名前の報告書が、フォルダ内に既に存在した場合、フォルダに既に保存している報告書を削除する。
%   \item ファイルには文字列"========報告者=========="を書き込んだ後にツールで設定した報告者の名前を書き込み、その後に文字列"========Warning========"を書き込む。
%   \item 4.8節の5.の二次元配列に格納している、キャラクターと重なったオブジェクト名と時刻をファイルに追記する。
% \end{enumerate}

% 図4.3に、報告書のフォーマットを示す。
% 2行目の[報告者名]には、テスト支援ツールのデータ入力部で設定した報告者名を表示する。
% 4行目の[キャラクター名]には、キャラクター情報入力ウィンドウで設定したキャラクター名を表示する。
% また、4行目の[オブジェクト名]には、キャラクターと重なったオブジェクト名を表示する。
% [時刻]には、キャラクターとオブジェクトが重なった時刻を表示する。

% % \begin{figure}[t]
% %   \centering
% %   \includegraphics[width=9cm]{./Image/4.2.eps}
% %   \caption{報告書のフォーマット}
% % \end{figure}

% \section{入力キーとタイミングの記録機能}\label{atari}
% ユーザーがリプレイ機能を使うためには、リプレイファイルが必要となる。リプレイファイルはcsv形式でデータを保存する。
% リプレイファイルへの記録は、ゲームスタートボタンを押下し、生成したフォアグラウンドウィンドウのタイトルが、指定したゲームのタイトルと同じだった場合にスタートする。
% 以下に、リプレイファイルへの時刻の記録の処理を示す。

% \begin{enumerate}
%   \item プログラム開始からの時間を計測する。
%   \item ゲームウィンドウがフォアグラウンドウィンドウになった時、ゲーム起動からの経過時間を保存する。
%   \item ユーザーがキーを押したことを判断する。
%   \item 対象とするキーを押下した場合、「キーを押下した時刻 - 2.で保存した時刻」を計算し、押したキーと、キーを押下した時刻をそれぞれ配列に代入する。
%   \item キーを離した場合、「キーを離した時刻 - 2.で保存した時刻」を計算し、4.の配列にキーを離した時刻を代入する。
%   \item ゲーム画面を閉じた際に、保存する予定のファイル名と同じ名前のファイルが、既に存在する場合、既に存在するファイルを削除する。
%   \item 4.と6.で出力したキー名と時刻を、リプレイファイルにカンマ区切りで書き込む。
% \end{enumerate}

% 図4.4に、csv形式のリプレイファイルのフォーマットを示す。
% リプレイファイルの1列目の[入力したキー名]には、入力したキーの名称を表示する。
% 2列目の[キーを押下した時刻]には、そのキーを押下した時刻を表示する。
% 3列目の「キーを離した時刻」には、そのキーを離した時刻を表示する。

% % \begin{figure}[t]
% %   \centering
% %   \includegraphics[width=10cm]{./Image/4.3.eps}
% %   \caption{リプレイファイルのフォーマット}
% % \end{figure}

% \section{リプレイ機能}\label{memo}
% 「リプレイ機能」の実装方法について説明する。データ入力部で設定した、リプレイファイルを利用して、
% ゲームをリプレイする。リプレイボタンを押下し、ゲームを実行すると、キーを自動で入力し、キャラクターを自動で動かす。

% \begin{enumerate}
%   \item csv形式のリプレイファイルを読み込む。
%   \item 1.で読み込んだファイルを1行ずつ取得する。
%   \item 最初に1列目のキーを取得する。
%   \item 3.で取得したキーを、キーに対応した10進数に変換する。
%   \item 2列目の値である、キーを入力した時刻を取得し、取得した時刻が現在時刻を過ぎていたら、1列目のキーを自動で押した状態にする。
%   \item 5.が終了したら、3列目の値である、キーを離した時刻を取得する。
%   \item 現在時刻が、6.で取得した時刻を過ぎていたら、3.で取得したキーを自動で離した状態にする。
% \end{enumerate}

% \section{エラーメッセージ出力機能}\label{memo}
% 「エラーメッセージ出力機能」の実装方法について説明する。エラーメッセージ出力機能は、
% 3.2.10節で説明している状態の場合、テスト支援ツールのエラーメッセージ出力表示部にエラーメッセージを表示する。

%\input{CommonTexs/Items_Area}
%以降、それぞれの処理部について説明する。



